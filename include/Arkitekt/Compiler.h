#pragma once
#include <unordered_map>
#include <string>
#include <cstdint>
#include <string_view>
#include <dynasm/dasm_proto.h>
struct Action;
namespace Arkitekt
{
    struct FnBlock;
    struct FunctionDefinition;
    using ::Action;
    struct Assembler;
    struct MemoryManager;
};
using namespace Arkitekt;
using Arkitekt::FunctionDefinition;
using Arkitekt::FnBlock;

using CHashMapHash = size_t;
struct dasm_State;

struct Action;

template <typename T> CHashMapHash CHashMapCalculateHash(T value)
{
    return std::hash<T>()(value);
}
namespace Arkitekt
{
/// @brief struct for storing functions generated by DynASM, contains the pointer to the memory where the function is stored, the size of the memory allocation and a pointer to the function itself
    struct FnBlock
    {
/// @brief pointer to the memory where the function is stored
        void* m_Mem;
        /// @brief size of the memory allocation in bytes
        size_t m_Size;
        /** @brief pointer to the function itself, used to call the function
        * this one you can touch
        **/
        void* m_Fn;
        /**
        * @brief Just leave this alone lol
        **/
        void** m_Labels;
        /**
         * @brief constexpr default constructor for allocating
         * Someday this will be usable to allocate memory at compile time
         */
        constexpr FnBlock( ) = default;
        /**
         * @brief Actual runtime constructor for FnBlock, protected because it is meant to be called only be create.
         * @param _mem
         * @param _size
         * @param _fn
         * @param labels
        **/
        FnBlock(void* _mem, size_t _size, void* _fn, void*** labels) : m_Mem(_mem), m_Size(_size), m_Fn(_fn), m_Labels(*labels) { }

        static Arkitekt::FnBlock& Create(FnBlock* ptr, const std::string_view& name, void* _mem, size_t _sz, void* _fn, void**& labels);
    };

    /// @brief struct for generating functions at runtime using DynASM, contains the state of the assembler, a map of generated functions and frees those functions on destruction. Currently only used to generate assembly for function hooks, will also contain scripts created by users at runtime in the future.
    struct Assembler
    {
        friend struct Arkitekt::FnBlock;
    public:
        static Arkitekt::Assembler* Get( );
    protected:
            /// @brief pointer to the DynASM state, must be used at the top of any function that generates code using DynASM, declared as dasm_State** dst = &this->dasm because this is how DynASM's preprocessor expects it. Is allocated newly for each function generated (by calling Assembler::Begin) and freed after the function is finalized (by calling Assembler::End, because I didn't know any other way to do it, and DynASM is virtually undocumented).
        dasm_State* dasm;
        /// @brief maximum number of local variables that currently have space allocated for them. If the number of local variables used in a function exceeds this number, more space will be allocated for them. This is necessary because we don't know how many local variables a function will use until we generate the code for it.
        unsigned long maxlocals;
        /// @brief identifier for the next local variable or label to be defined, incremented every time a new local variable or label is defined. Used by DynASM for its internal bookkeeping, incremented by the Assembler functions that define local variables or labels, and reset to 0 when the Assembler is destructed (which happens after each function is generated).
        unsigned long nextlocal;
        /// @brief call this to initialize the assembler, must be called before any other function of the assembler is called, and exactly once per function. Returns true if the initialization was successful, crashes the program otherwise (because we aren't chancing emitting assembly when the Assembler state is invalid).
        bool Init( );
        /// @brief map of FnBlocks generated by this assembler, indexed by the hash (murmurhash) of the function name. Used to free the generated functions on destruction of the assembler, and to look up functions by name to call from user scripts.
        std::unordered_map<uint32_t, FnBlock*> _blocks;
        /// @brief map of script names to their hashes, used to look up function names by their hash (for debugging purposes within user scripts, not used by the Assembler itself).
        std::unordered_map<uint32_t, std::string_view> m_scriptNames;
        /// @brief currently unused. Will map local variable allocated storage to script hashes (for all local variables per script) in the future.
        std::unordered_map<uint32_t, void*> m_Locals;
        /// @brief constructor and destructor, the constructor initializes the member variables to their default values, and the destructor frees all generated functions and resets the member variables. The destructor must only be called on program exit. Calling it during runtime would cause all generated functions to become invalid (as they would be freed) and would crash as soon as any of those functions is called. (including any function hooks). This is protected for a reason.
        Assembler( ) : _blocks {}, m_Locals {}, dasm(nullptr), nextlocal(0), maxlocals(8) { };
        ~Assembler( ) = default;
    public:
        FnBlock* FinalizeFunction(const std::string_view& name, void**& _labels);
        void Begin(void*** _labels);
        void End( );
        void EmitHookWrapper(FunctionDefinition* forFunction, void* _targetHook);
        void EmitSuperWrapper(FunctionDefinition* forFunction, void* _targetSuper);
    };
}

